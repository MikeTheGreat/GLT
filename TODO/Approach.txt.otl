The GitLab API is rather good and you could use it for all of your repo setup with permissions and whatnot. Here is what I think you'd want to do.

Create a script that will create a group in GitLab for homework assignment. The script could then pull in the users from the class that this assignment is for. It would then create a privite repository in this group for each student from the class. It could then also email them the link to the newly created git repository for their assignment.

If you wanted to include instructions within the repo about the assignment, create a base git repo with a README.md file explaining the details for each assignment. Then for repository creation, create a fork of this repository for each student as a private repository (basically like above except we are forking instead of creating an empty repository).

For being able to grade offline, I'd say you'd want to write a script that would check out every git repository in a given group. That would give you each students submissions for the homework assignment with one script.

Further down the road ...
You could also turn on GitLab CI for automatic evualuation of the assignment. This would essentially build the code into a live environment to run tests against and return the results. Going this route would also be beneficial to do the forking method as the jobs in CI are all controlled by a '.gitlab-ci.yml' file. Forking the base repo with this file will automatically add CI jobs for the newly created fork'd repository.

If you had a long running project that went the length of a class (ie a webapp, start with a home page, add shopping cart, add this, add that), then you could also automaticlaly assign new assignments by creating an issue in the project for each repository in the group (through the API). So maybe the base repo everyone forks from is an empty Rails project or something. Then you could add an issue against everyone's forks to add a model that creates these tables in the database. Add another issue to setup user login, etc.

## Create student accounts workflow:
	Read in a file of students, and create an account for each one
		If a student already exists then ignore that one
		output errors to standard out
		Append newly created students to a 'known good' list file for this class
	
	'Known good' account list will be used in all workflows below this point

## Delete student accounts workflow:
	Read in the known good account list for the specified section
	Delete all user accounts for that section
		Remove deleted accounts from the 'known good' list
	
## Setup for each HW assignment:
	Load this up using a config file.
		Each line should have: GROUP_NAME, PROJECT_NAME, [LOCAL_GIT_REPO_TO_MERGE_AND_PUSH - optional]
		The idea is that a line might look like BIT_142, Assignment_1_BIT_142, E:\work\starter projects\BIT 142\Assign1
		The last, optional argument can be used to auto-load stuff into GitLab
	If the group doesn't exist already then create it  (all items private to the world by default)
	Allow each student access to the new group
	Create private project in group
		Uncheck 'merge requests', so students can't submit pull requests (which would be visible to other students)
		Leave the main branch protected, so that students can't change the instructor's copy (which others can see)
		Allow each student access to the new project
	If a local git repo is specified:
		Download the project to a local git folder
		Merge the optional repo in (this should always work since the GitLab project is empty)
		Push the changes back to GitLab
		TODO: Remember to set up a .gitignore file that'll filter out the cruft (bin, obj, etc)

## Student workflow:
	Log in to GitLab
	Find the project for their assignment
	Fork the assignment
	   When student forks the project it'll be private by default (b/c it inherits from origin)
			   TODO: Tell students they must keep the project private!!
	   These projects keep the origin project's name by default.
			   Renaming it is hidden in the settings page, and has  warning next to it
			   TODO: Tell students they can't change the name
	   New, forked project is put under the student's namespace (so we can't look for projects within the group)
	   If the student attempts to fork a second time in the GitHub website they will instead go to their already-created fork
	Clone to their local machine
	Do the work
	Add & commit locally
	Push back to the server

## Grading (Retrieve Student Work) workflow:
	Use the API to get a list of all projects, filter that list for only items that match the project name
	   (use Python's filter function?)
	For each student project on GitLab:
	   Allow the administrator account access to the project (so we can push to it later)(TODO: Do we need to do this?)
	   Within the assignment sub-dir, create a local sub-sub-dir for that student student (ST-style)
	   Do a local clone into that dir (or if it exists then pull in order to 'freshen' it)
		   Build a list of things that need to be updated based on whether the student last committed to it or I did

## Grading (Send Feedback To Students) workflow:
	As I grade, leave feedback files in the local repos
	Run a script which will iterate through all the local repos:
		Add all files there (i.e., the feedback file) and commit
		Tag the commit as the "initial version"
		Push the commit to the server
	Post an announcement through ST/Canvas telling everyone to go get their feedback

## Revising Student Work workflow:
	Student keeps working in the same repo
	Student commits work locally, then pushes to GitLab
	Re-use Retrieve Student Work workflow to mass-pull changes
	Instructor grades
	Re-use Send Feedback To Students to send feedback & tag revision

## Backups for later workflow:
	Foreach local, student repo:
		Get the 'current commit' (head?)
		checkout the appropriate tag
		Copy the dirs to the backup location
			Remove/avoid the .git directory
		Restore the 'current commit'

## End of quarter clean-up
	TODO: Finish filling this out
	Remove student accounts
	Remove all their projects
	Remove groups
		Including any starter projects in the groups

## GitDo: execute a <shell script> once per git repo, given a list of git repos
	This could be used to add files to everyone's git repos, commit the file, and then push the changes
